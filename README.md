- [Ethereum-Solidity-SmartContracts](#ethereum-solidity-smartcontracts)
  - [What is ethereum network?](#what-is-ethereum-network)
  - [Address & Keys](#address--keys)
  - [Transaction](#transaction)
    - [Properties of transaction object](#properties-of-transaction-object)
  - [Transaction flow of demo](#transaction-flow-of-demo)
  - [Why wait?](#why-wait)
  - [In detail](#in-detail)
  - [BlockChain 101](#blockchain-101)
    - [Hash, Block and Blockchain](#hash-block-and-blockchain)
    - [How blocks are intact](#how-blocks-are-intact)
    - [Distributed BlockChain](#distributed-blockchain)
    - [How to make this blockChain userful? Token!](#how-to-make-this-blockchain-userful-token)
    - [Problem with current Block!](#problem-with-current-block)
    - [Coinbase transaction](#coinbase-transaction)
    - [Applying general ideas to Ethereum](#applying-general-ideas-to-ethereum)
    - [Hash range](#hash-range)
    - [Block Time](#block-time)
    - [Why difficulty target number is adjusted?](#why-difficulty-target-number-is-adjusted)
  - [SmartContracts](#smartcontracts)
    - [Accounts](#accounts)
    - [Hands on on solidity](#hands-on-on-solidity)
    - [BIG GOTCHA!! Don't assume testing environment is real](#big-gotcha-dont-assume-testing-environment-is-real)
    - [Gas??](#gas)
    - [12 word mnemonic](#12-word-mnemonic)
    - [Compiling first smart contract](#compiling-first-smart-contract)
    - [Testing](#testing)
    - [Connecting to Rinkeby Network](#connecting-to-rinkeby-network)
    - [Hands on with Remix Injected Web3](#hands-on-with-remix-injected-web3)

# Ethereum-Solidity-SmartContracts

## What is ethereum network?

- Ethereum networks are used to transfer money and store data
- There are many different Ethereum networks(Test, private, and etc)
- Networks are formed by one or more nodes
- Each node is just a machine(Like your laptop) running an ethereum client
- Anyone with machine can run a node via ethereum client
- Each node can contain a full copy of the blockcahin(DB of transactions)
- The blockchain is a db that stores a record of every transaction that's ever taken place

## Address & Keys

- Account Address is like a user id or email address
- public and private key combined works like a password
- keys are used to authorize the sending of funds
- keys stored of hexadecimal numbers
- An account is used across every ethereum network (Doesn't mean you can't create more of them!)

## Transaction

- An account is used across all networks, however tokens the account has is unique to the network
- Transaction is a record that one account attemtpting to send money to another account
- It is created whenever two accounts exchange money
- During the demo, transaction object was created and sent to the ethereum network to be processed

### Properties of transaction object

- nonce : # of times sender has sent a transaction
- to : Address of receiver
- value : Amount of ether to be sent
- startGas/gasLimit : units of gas that this transaction can consume
- v, r, s : These are generated by senders' private key to be used to generate the senders account address
- If you have private key you can generate v, r, and s but not the other way around

## Transaction flow of demo

- Submit form with receiver's address
- server receives the address and create transaction object using web3 library
- the server sends transaction object to the Rinkeby test network
- the server **waits** for transaction to be confirmed
- the server sends success message to the client

## Why wait?

- Because it attempts to replace traditional financial system such as USD EURO and etc..
- which is extremely complicated task

## In detail

- Transaction is sent to a single node in a network
- Assuming that there were two other transactions submitted to the node at the same time we submitted transaction,
- The node creates a **block** that contains list of transactions
- The node runs validation on the block which was the reason why there is some processing time before the transaction is complete
- The validation processing is referred to the **Mining**

## BlockChain 101

### Hash, Block and Blockchain

- **Hash** is like a fingerprint of some data after processed by hash function
- You can get a hash out of data, regardless of its size. But you cannot guess what the data is out of hash
- Block has block number, Nonce, data, and prev and hash
- **Block** is signed when it's first four letters are all zeros 0000kjfljflkwelkfjlwkfe like so
- Block number is a position of block in blockchain
- prev is hash of previous block. Prev of first block is 00000000... all zeros
- **Mining** is a process of finding value of **Nonce** that makes the block signed

### How blocks are intact

- If you alter some arbitary block in the chain by changing its data,
- You are essentially changing it's hash and will make it unsigned
- You need to mine that block to make it singed again by changing its Nonce
- But as the hash of this block is changed, the next block's hash is also altered.
- So next block isn't signed anymore.
- So basically altering a block results in altering all the following blocks which is extremely expensive as you go back in time more and more
- This is how block chain **resists** against mutation

### Distributed BlockChain

- Assuming that there are many numbers of blocks in the block chain
- And many peers have complete copy of this block chain
- We know that altering any block in the chain will eventully change the hash of next blocks
- So by comparing very last hash of block in the chain with other peers' block chain,
- The unaltered block chain easily dominates the altered block chain

### How to make this blockChain userful? Token!

- The data part of block is used as token which contains list of transactions.
- Because of nature of block and blockChain, recored of these transactions are **immutable**.

### Problem with current Block!

- Transcactions in the block only contains who sent how much to whom.
- Which bring a question of "does the sender actually has x amount of money to send?
- What is the balance of a sender?

### Coinbase transaction

- Coinbase transaction is a special transaction where sender is coinbase and receiver is some address
- There is no previous of transaction flow to coinbase
- So by tracking coinbase transaction and transaction between addresses,
- We can now see if certain adress has balance to make the transaction or not.

### Applying general ideas to Ethereum

- If you convert output hash which is hexadecimal number to decimal number, it results in some numbers, in base 10
- In reality, what we are looking instead is this base 10 number, which is converted from hash output.
- More specifically whether to evaluate whether the block is signed or not, we look at the hash in base 10 value and check whether it is lower than some number.
- So mining is a process of finding hash output by changing nonce that is lower than some number in base 10

### Hash range

- The hash output we're dealing with is hexadecimal number that is 64 chars long.
- in decimal this is from 0 to -15 \* 10 ^ 77
- From 0x0 _ 64 to 0x f _ 64

### Block Time

- Modern computers can run a lot of hashes simultaneously, but given the target decimal number we're looking for is relative so small than entire range of our hash output.
- So even though computers are super fast, it takes some amount of time to figure out our target hash and this some amount of time is called **Block Time**
- Ethereum has target block time of **15 seconds**. The variable here is that target number.
- However, this target number fluctuates as determined by network.
- The network mesaures the block time of previous block and set target number of next block accordingly to meet that 15 seconds block time.

### Why difficulty target number is adjusted?

- The computing availability of network is determined by nubmer of nodes online in the network.
- So more nodes mean more calculating power and vice versa.

## SmartContracts

### Accounts

**Smart contract** accounts are controlled by code and instructs how smart contract behaves
It has following properties

- Balance: this is amount of ether this account has
- Storage: This stores whatever data that is related to the app we're building. Could be numbers, strings, and etc..
- Code: It is a raw machine code for this contract. The code that developer write in the account is converted and stored in the form of raw machine code

**External accounts** are user accounts that any entity or human being owns. It is decoupled from any network. This account can be used in any kind of different networks

**Contract accounts** are specific to individual network. If you deploy the contract account to a single network, it lives in that network. If you were to deploy that account to other network, you need to take the code and create totally new account and redeploy it in other network.

### Hands on on solidity

**The contract source** (the code you wrote in contract account) can be deployed multiple times in a single network or can be deployed across networks. This relationship is similar to what we have in programming world. Like a class and instance.

**Solidity** is

- Written in .sol files
- Strongly typed
- similar to Javascript
- Has very big gotchas

The solidity we write gets compiled and spits two different things.
A byte code that is ready to be deployed in a network.
And Application binary interface (ABI) that serves as interface between client and deployed contract account

Solidity function types

- Public or private: Anyone (with ethereum account) or only this contract can call this function
- View and constant : these are the same thing, this function returns data and does not modify contract's data
- Pure: function does not modify or read the contract's data
- Payable: calling this function means caller might send ether along

**If function modifies the data in our contract, the function cannot return any value**

Simple Demo

```solidity
//To inform which version of compiler we're using
pragma solidity ^0.4.17;

contract Inbox {
    string private message;

    function Inbox(string initialMessage) public {
        message = initialMessage;

    }

    function setMessage(string newMessage) public {
        message = newMessage;
    }

    function getMessage() public view returns (string) {
        return message;
    }
}
```

**Contract creation**
A deploying contract to network is similar to what normal transaction for sending money is like
The difference is that

- **to** field in the transaction is left blank
- **data** field is the bytecode of the contract. Since the data field of transaction is visible to everyone with an account, thus the code is also visible to others
- value field is used to set initial money that the contract gets
- Just as normal transaction, v,r and s key is used to verify account address using private key.

**Two ways of using function**
If you notice in our function, there are two ways to use the function.

- setMessage to alter message variable
- getMessage to fetch current message data

Reading or fetching data involves looking back to previous data on a blockchain. Setting or altering data involves in creating another transaction. This means

- Reading data does not need to be mined
- Setting data requires mining

Calling function (reading data) does not modify data, can return a data, runs instantly, and is free

Sending a transaction to a function can modify a contract's data, it takes time to execute (15~30 seconds), returns transaction hash, it costs money, there is no return value.

### BIG GOTCHA!! Don't assume testing environment is real

Notice if you invoke set message and send a transaction. It is instant. It is only because we're in the testing suite. However, if the contract is deployed in real network like ether main or some other networks. Because of set block time, it will take at least 15 seconds.

When creating a smart contract accounts, it is essential not to assume that sending a transaction is an instantenous task.

### Gas??

A **Gas** is a unit which you must pay in order to send a transaction. The price of gas sending transaction for specific function is determined by **smart contract** However, when you send a transaction, you can set gas limit so that the cost won't exceed the gas limit you set.

You can also specify unit you're willing to pay per gas. For example, if you set gas price of 100 wei, and seding a transaction costs 10 gas, the total cost is \*_100 wei/gas _ 10 gas \* = 1000 wei

### 12 word mnemonic

The 12 word mnemonic generated as we set up metamask solves a problem by having to memorize address, public and private key. If you have multiple ethereum accounts, it will be extremely painful to memorize these combinations. So instead, 12 word mnemonic using BIP42 algorithm, generates series of address, private and public key.
https://iancoleman.io/bip39/#english

### Compiling first smart contract

The code we wrote above with remix can go directly into inbox/contracts/inbox.sol
Then inside the compile file,

```javascript
// compile code will go here
const path = require("path");
const fs = require("fs");
const solc = require("solc");

const inboxPath = path.resolve(__dirname, "contracts", "Inbox.sol");
const source = fs.readFileSync(inboxPath, "utf8");
module.exports = solc.compile(source, 1).contracts[":Inbox"];
```

Notice we used path to make sure compiling is cross compatiable
We then read file content and assign it to source variable. finally export the compiled version of contract. In our case, specifically the inbox contract. This process is supposed to handle multiple smart contracts.

When smart contract written in solidity is compiled,

- It Produces Byte code and ABI
- Byte code is deployed in our local test network by Ganache
- We're going to communicate with contract using web3 utilizing ABI

### Testing

In our test/Inbox.test.js
Our test flow is as follows

1. Mocha starts
2. deploy a new contract (before each)
3. Manipulate the contract (it)
4. Make an assertion about the contract (it)

When we are connected to local test network using web3 through ganache, the external account that will be used to deploy smart contract is automatically generated so that we dont have to worry about private keys and etc. These accounts are so called Unlocked Accounts

Actual implementation of deploying a contract

```javascript
// contract test code will go here
const assert = require("assert");
const ganache = require("ganache-cli");
const Web3 = require("web3");
const web3 = new Web3(ganache.provider());
const { interface, bytecode } = require("../compile");
let accounts, inbox;
beforeEach(async () => {
  // Get a list of all accounts
  accounts = await web3.eth.getAccounts();
  // Use one of those accounts to deploy the contract
  inbox = await new web3.eth.Contract(JSON.parse(interface))
    .deploy({
      data: bytecode,
      arguments: ["Hello Mo"],
    })
    .send({ from: accounts[0], gas: "1000000" }); // gasLimit for this transaction
});

describe("Inbox", () => {
  it("deploys a contract", () => {
    asssert.ok(inbox.options.address);
  });
});
```

If you console log inbox, there is providers property. It has 3 different providers but the IpcProvider is used when you use same machine to test your network

Below is testing initial constructor and setMessage method

```javascript

describe("Inbox", () => {
  it("deploys a contract", () => {
    assert.ok(inbox.options.address);
  });
  it("has a default message", async () => {
    const message = await inbox.methods.getMessage().call();
    assert.equal(message, INITIAL_STRING);
  });

  it("updates a message", async () => {
    await inbox.methods
      .setMessage(`${INITIAL_STRING}s`)
      .send({ from: accounts[0] });
    const message = await inbox.methods.getMessage().call();
    assert.equal(message, `${INITIAL_STRING}s`);
  });

```

### Connecting to Rinkeby Network

Difference between deploying a contract to local test network and Rinkeby Network is that we now have to worry about all theses security stuff and make sure that the account actually has some ether in it.

We need to connect to a node that exists inside rinkeby network. We can solve this by running a local ethereum node and use it to connect to network

However due to its complexity, we'll use infura api which works like a portal to connect to rinkeby network. Infura already has a node inside rinkeby network. So using provider from infura api, we can connect to infura node in rinkeby network

Earlier we used ganache to easily connect to the network. However, in order to connect to a real network, we need to set up the provider manually. We need to use it to unlock an account and set where it will connect to. @truffle/hdwallet-provider module will do the job.

```javascript
// deploy code will go here
const HDWalletProvider = require("@truffle/hdwallet-provider");
const Web3 = require("web3");
const { interface, bytecode } = require("./compile");

const provider = new HDWalletProvider(
  `sauce afford between wool awake please gown retreat idle tongue hard bright`,
  "https://rinkeby.infura.io/v3/4361b168992b4cd692c5a70114367e64"
);

const web3 = new Web3(provider);

const deploy = async () => {
  const accounts = await web3.eth.getAccounts();
  const inbox = await new web3.eth.Contract(JSON.parse(interface))
    .deploy({
      data: bytecode,
      arguments: ["DOOJI!!"],
    })
    .send({ from: accounts[0], gas: "1000000" }); // gasLimit for this transaction
  console.log(inbox.options.address);
};
deploy();
```

Now connecting and deploying a contract to rinkeby is very similar to what we did in the test setting. The only difference is that we are now using our actually account from metamask that holds test ether by injecting tne mnemonic, and setting the endpoint to what we got from infura.

### Hands on with Remix Injected Web3

Now proceed to remix and choose deploy & run from left side menu
Set environment to Injected Web3
This immediately attempts connect to your account through metamask
Allowing this will set account in remix to your account.
If you now add the contract address to At address in remix
You can interact with it by paying actual ether that your test account has
Notice how sending transaction actually takes quite some time!
